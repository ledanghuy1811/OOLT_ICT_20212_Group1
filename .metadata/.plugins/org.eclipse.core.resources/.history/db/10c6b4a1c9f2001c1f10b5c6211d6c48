package algorithms;

import graph.*;

public class BellmanFord extends Algorithms {
	
	// override
	@Override
	public void execute() {
		
	}
	@Override
	public void play() {
		//Relax all edges |V| - 1 times. A simple
        // shortest path from src to any other vertex can
        // have at-most |V| - 1 edges
        for (int i = 1; i < this.getNumVertex(); ++i) {
            for (int j = 0; j < this.getGraph().getEdge().length; ++j) {
                for(Edge e : this.getGraph().getEdge()[j]) {
                	int u = e.getNodeSource();
                    int v = e.getNodeTarget();
                    double weight = e.getWeight();
                    if (
                    	this.getDist()[u] != Double.MAX_VALUE && 
                    	this.getDist()[u] + weight < this.getDist()[v]
                    )
                        this.setOneDist(v, this.getDist()[u] + weight);
                }
            }
        }
        //check for negative-weight cycles. The above
        // step guarantees shortest distances if graph doesn't
        // contain negative weight cycle. If we get a shorter
        // path, then there is a cycle.
        for (int j = 0; j < E; ++j) {
            int u = graph.edge[j].src;
            int v = graph.edge[j].dest;
            int weight = graph.edge[j].weight;
            if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {
                System.out.println("Graph contains negative weight cycle");
                return;
            }
        }
	}
}
