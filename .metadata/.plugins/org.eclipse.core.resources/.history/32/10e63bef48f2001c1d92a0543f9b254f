package algorithms;

import java.util.*;

import graph.*;
import test.Node;

public class Dijkstra extends Algorithms {
	// Member variables of this class
    private double dist[];
    private Set<Vertex> settled;
    private PriorityQueue<Edge> pq;
	
    //constructor
    public Dijkstra() {
    	super();
    }
    public Dijkstra(Graph graph, int numVertex, Vertex source) {
    	super(graph, numVertex, source);
    	this.dist = new double[numVertex];
    	this.settled = new HashSet<Vertex>();
    	this.pq = new PriorityQueue<Edge>();
    }
    
    //method
    private void e_Neighbours(int u)
	{

		int edgeDistance = -1;
		int newDistance = -1;

		// All the neighbors of v
		for (int i = 0; i < adj.get(u).size(); i++) {
			Node v = adj.get(u).get(i);

			// If current node hasn't already been processed
			if (!settled.contains(v.node)) {
				edgeDistance = v.cost;
				newDistance = dist[u] + edgeDistance;

				// If new distance is cheaper in cost
				if (newDistance < dist[v.node])
					dist[v.node] = newDistance;

				// Add the current node to the queue
				pq.add(new Node(v.node, dist[v.node]));
			}
		}
	}
    
	//override
	@Override
	public void execute() {
		Vertex src = this.getSource();
		ArrayList<Edge> adj[]= this.getGraph().getEdge();

		for (int i = 0; i < this.getNumVertex(); i++)
			dist[i] = Double.MAX_VALUE;

		// Add source node to the priority queue
		pq.add(new Edge());

		// Distance to the source is 0
		dist[src] = 0;

		while (settled.size() != V) {

			// Terminating condition check when
			// the priority queue is empty, return
			if (pq.isEmpty())
				return;

			// Removing the minimum distance node
			// from the priority queue
			int u = pq.remove().node;

			// Adding the node whose distance is
			// finalized
			if (settled.contains(u))

				// Continue keyword skips execution for
				// following check
				continue;

			// We don't have to call e_Neighbors(u)
			// if u is already present in the settled set.
			settled.add(u);

			e_Neighbours(u);
		}
	}
}
